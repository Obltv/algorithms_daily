# Java 包装类型常量池与 `equals` 比较

## 包装类型的常量池有哪些类型？为什么比较时用 `equals`？

在 Java 中，包装类型（如 `Integer`、`Character`、`Double` 等）有一个常见的技术池机制，这主要是为了节省内存和提高性能。这些包装类在一定范围内会缓存对象，这个缓存叫做“常量池”或“值缓存池”。这个常量池机制可以减少对相同值对象的重复创建，特别是对于小范围的整数和字符。

### 1. **Integer 常量池**
`Integer` 类的常量池机制主要是针对从 `-128` 到 `127` 范围内的整数。在这个范围内，`Integer` 对象是共享的。当你创建一个在这个范围内的 `Integer` 对象时，Java 会从缓存池中返回已有对象，而不是重新创建一个新的对象。超出这个范围时，`Integer` 会创建新的对象。

### 2. **Character 常量池**
类似于 `Integer`，`Character` 也会缓存字符 `\u0000` 到 `\u007F`（即 ASCII 字符集的范围）。当你创建一个 `Character` 对象时，如果字符在这个范围内，Java 会复用池中的对象。

### 3. **Short 和 Byte 常量池**
`Short` 和 `Byte` 也采用了类似 `Integer` 和 `Character` 的常量池机制。`Short` 类型的常量池范围为 `-128` 到 `127`，`Byte` 类型的常量池范围也为 `-128` 到 `127`。

### 为什么比较时用 `equals`？
虽然这些包装类有常量池机制，但它们依然是对象，因此直接使用 `==` 比较的是对象的引用地址，而不是值。因此，如果想比较两个包装类型对象的值是否相等，就需要使用 `equals` 方法。

#### 举例：
```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);        // true，因为 Integer 的缓存池作用
System.out.println(a.equals(b));  // true，比较的是值

Integer c = 200;
Integer d = 200;
System.out.println(c == d);        // false，超出了缓存池范围，创建了新的对象
System.out.println(c.equals(d));  // true，比较的是值
```

# 为什么 `int` 可以直接用 `==` 比较，而包装类不能？

`int` 类型的变量之所以可以直接使用 `==` 进行比较，而不需要使用 `equals`，是因为它是**基本数据类型**（primitive type），而不是对象。

## 基本数据类型 vs 包装类
- **基本数据类型**（如 `int`、`char`、`boolean` 等）存储的是实际的值。例如，`int a = 100;`，`a` 存储的是值 `100`，直接用 `==` 比较 `a` 时，比较的是值本身。
- **包装类**（如 `Integer`、`Character` 等）是对象类型，存储的是对象的引用（内存地址），即对象的引用指向堆内存中的实际数据。

## 为什么 `int` 可以直接用 `==` 比较
- **值比较**：`int` 类型存储的就是一个简单的数字值，`==` 运算符在基本数据类型中会比较两个值是否相等。如果两个 `int` 类型的值相等，`==` 会直接返回 `true`。

例如：
```java
int a = 100;
int b = 100;
System.out.println(a == b);  // true
```

# 常量池中的对象是否指向同一个地址？

是的，在常量池中的对象，特别是像 `Integer` 这样的包装类对象，通常会指向同一个地址。

## 为什么常量池中的对象指向同一个地址？

Java 的常量池机制（对于一些小范围的包装类型对象如 `Integer`、`Character` 等）是为了提高内存使用效率和性能。常量池会缓存这些对象，确保它们不会被重复创建。这样做的目的是为了节省内存，特别是对于常用的常量值（如小整数）。

### 常量池中的缓存机制：

- **范围限制**：对于 `Integer`，Java 默认只缓存 `-128` 到 `127` 之间的整数值。这些值会被缓存并指向相同的内存地址。当你创建一个 `Integer` 对象，值在这个范围内时，JVM 会返回常量池中的已存在对象，而不会重新创建新对象。
- **对象重用**：在常量池中的对象，指向的是同一个内存地址。也就是说，如果你创建多个 `Integer` 对象，值为 `100`（这个值在 `-128` 到 `127` 之间），它们将引用同一个对象，内存地址相同。

### 举例说明：

```java
Integer a = 100;  // a 指向常量池中的对象
Integer b = 100;  // b 也指向常量池中的对象
System.out.println(a == b);  // true，a 和 b 都指向同一个对象，内存地址相同
```

# `int` 类型变量在内存中的地址

## `int` 类型的内存存储

`int` 是 **基本数据类型**，它存储的是值，而不是引用。每个 `int` 类型的变量在内存中占用固定的空间（通常为 4 字节），并且它们的存储位置是由编译器和运行时环境决定的。

## 内存中的地址是否相同？

### 1. **栈内存分配**
- 当你声明一个 `int` 类型的变量时，JVM 会在 **栈内存** 中为它分配空间。每个 `int` 变量都有自己的内存地址（栈上不同变量的地址是不同的）。
- 即使两个 `int` 类型的变量的值相同，它们在栈中的内存地址也是不同的，因为它们是独立的变量。

### 2. **常量池和堆内存**
- **常量池**：对于包装类型（如 `Integer`），JVM 会根据常量池机制来决定是否复用对象的内存地址。但这只适用于包装类型对象（如 `Integer`），并不适用于基本数据类型 `int`。
- **堆内存**：因为 `int` 是基本数据类型，它不会像对象那样在堆内存中分配内存或使用常量池，所以即使它们的值相同，它们的内存地址也是独立的。

### 举例：
```java
int a = 100;
int b = 100;
System.out.println(System.identityHashCode(a));  // 输出 a 的内存地址
System.out.println(System.identityHashCode(b));  // 输出 b 的内存地址
```


